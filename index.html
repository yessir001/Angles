<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Penguin Angle Quiz ‚Äî 3 Questions</title>
  <style>
    :root{
      --bg1:#a8e6ff; /* sky */
      --bg2:#eaf7ff; /* clouds */
      --panel:#ffffff;
      --ink:#1f2d3a;
      --accent:#ff7aa2; /* pink */
      --accent2:#7ad1ff; /* blue */
      --good:#22c55e; /* green */
      --bad:#ef4444; /* red */
      --gold:#ffcd3c; /* confetti */
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family: ui-rounded, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial;
      color:var(--ink);
      background:
        radial-gradient(ellipse at 20% 10%, #ffffff88 0 20%, transparent 21%),
        radial-gradient(ellipse at 80% 15%, #ffffff88 0 18%, transparent 19%),
        linear-gradient(180deg, var(--bg1), var(--bg2));
      display:grid; place-items:center; padding:16px;
    }
    .app{ width:min(980px, 100%); background:var(--panel); border-radius:24px; box-shadow:0 10px 30px #0000001a; overflow:hidden; border:4px solid #fff; position:relative; }
    header{ display:flex; align-items:center; justify-content:space-between; padding:14px 18px; gap:12px; background:linear-gradient(90deg, #fff, #f8fbff); border-bottom:1px dashed #e5f1ff; }
    .title{font-size:clamp(18px,2.6vw,26px); font-weight:800; letter-spacing:0.2px}
    .pill{ display:inline-flex; align-items:center; gap:8px; background:linear-gradient(90deg, var(--accent), var(--accent2)); color:#fff; padding:8px 12px; border-radius:999px; font-weight:700; box-shadow:0 3px 10px #8ad1ff66; }

    .wrap{display:grid; grid-template-columns: 320px 1fr; gap:0;}  @media (max-width: 860px){ .wrap{grid-template-columns:1fr;} }

    /* Penguin Panel */
    .penguin-card{ background:linear-gradient(180deg, #e8f7ff, #ffffff); border-right:1px dashed #e5f1ff; padding:18px; position:relative; min-height:360px; display:flex; flex-direction:column; align-items:center; justify-content:center; overflow:hidden; }
    .penguin-stage{ width:220px; height:240px; position:relative; z-index:10; }
    .ground{ position:absolute; inset:auto 0 0 0; height:36px; background:linear-gradient(180deg,#dff6ff,#c9efff); border-radius:18px 18px 0 0;}

    /* SVG Penguin */
    svg{display:block}
    #penguin{ transform-origin:center; }
    /* Alternate eye blinks: left then right */
    .pupil{ transform-box: fill-box; transform-origin: center; }
    .pupilL{ animation: blinkL 7.6s infinite; }
    .pupilR{ animation: blinkR 9.2s infinite; }
    @keyframes blinkL{ 0%,44%,46%,100%{ transform: scaleY(1);} 45%{ transform: scaleY(0.12);} }
    @keyframes blinkR{ 0%,94%,96%,100%{ transform: scaleY(1);} 95%{ transform: scaleY(0.12);} }
    .celebrate{ animation: hop 0.9s ease-out 0s 2; }
    @keyframes hop{ 0%{transform:translateY(0)} 30%{transform:translateY(-20px)} 60%{transform:translateY(0)} 85%{transform:translateY(-10px)} 100%{transform:translateY(0)} }
    .sad{ animation: droop 1.1s ease both; }
    @keyframes droop{ 0%{transform:translateY(0)} 100%{transform:translateY(10px)} }
    .tear{ opacity:0; }
    .cry .tear{ animation: tear 1.2s ease-in forwards; }
    @keyframes tear{ 0%{opacity:0; transform:translateY(0)} 20%{opacity:1} 100%{opacity:1; transform:translateY(28px)} }
    #smile{ transition: all .25s ease; opacity:1; }
    .happy #smile{ transform: translateY(1px); stroke-width:5; }
    .happy #smile{ opacity:1; }

    /* Right side (Angle + Controls) */
    .play{ padding:18px; display:grid; gap:14px; background:conic-gradient(from 90deg at 80% -10%, #ffffff, #f9fcff, #ffffff); }
    .progress{ font-weight:800; font-size:14px; }
    .board{ background:#f7fbff; border:2px dashed #d4ecff; border-radius:18px; padding:10px; display:grid; place-items:center; min-height:320px; }
    .tip{font-size:12px; opacity:0.8; margin-top:-4px}

    #angleSvg{ width:100%; max-width:620px; height:auto; aspect-ratio: 3 / 2; }
    .base{ stroke:#222; stroke-width:4; }
    .ray{ stroke:var(--accent); stroke-width:6; stroke-linecap:round; }
    .arc{ stroke:#ffb3cb; stroke-width:6; fill:none; filter: drop-shadow(0 2px 0 #ffffffcc); }
    .arc.inner{ stroke:#ff8fb3; stroke-width:6; }
    .vertex{ fill:var(--gold); }

    .controls{ display:flex; flex-wrap:wrap; gap:10px; align-items:center; }
    .controls input[type=number]{ width:120px; padding:10px 12px; font-size:16px; border-radius:12px; border:2px solid #dbeafe; outline:none; font-weight:700; text-align:center; }
    .btn{ padding:10px 14px; font-weight:800; border:none; border-radius:14px; cursor:pointer; background:linear-gradient(90deg, var(--accent), var(--accent2)); color:#fff; box-shadow:0 6px 14px #8ad1ff66; }
    .btn.secondary{ background:#e9f5ff; color:#0b5b8e; box-shadow:none; border:2px solid #cceaff; }
    .btn:disabled{ opacity:0.6; cursor:not-allowed; }

    .feedback{ min-height:26px; font-weight:800; }
    .good{ color:var(--good);} .bad{ color:var(--bad); }

    .score{ font-size:14px; opacity:0.85; z-index:10; position:relative; }

    .cele-confetti{ pointer-events:none; position:absolute; inset:0; display:none; z-index:20; }
    .celebrate-on .cele-confetti{ display:block; }
  
    /* Enhanced snow effect */
    .snow{ 
      position:absolute; 
      inset:0; 
      pointer-events:none; 
      overflow:hidden; 
      z-index:5; /* Behind penguin but above background */
    }
    
    /* Snowflakes in penguin area */
    .penguin-snow{ 
      position:absolute; 
      inset:0; 
      pointer-events:none; 
      overflow:hidden; 
      z-index:15; /* Above penguin for foreground snow */
    }
    
    .snow span, .penguin-snow span{ 
      position:absolute; 
      top:-10px; 
      width:6px; 
      height:6px; 
      background:#fff; 
      border-radius:50%; 
      opacity:0.9; 
      filter: drop-shadow(0 0 2px #fff); 
      animation:snowFall linear infinite; 
    }
    
    .penguin-snow span {
      opacity: 0.7; /* Slightly more transparent for foreground snow */
      filter: drop-shadow(0 0 3px #fff) blur(0.5px); /* Softer for depth */
    }
    
    @keyframes snowFall{ 
      to{ 
        transform: translateY(calc(100vh + 20px)) rotate(360deg); 
        opacity:0.6; 
      } 
    }
    
    /* Varied snowflake animations for natural effect */
    @keyframes snowDrift{ 
      0%, 100% { transform: translateX(0) translateY(0); }
      33% { transform: translateX(30px) translateY(33vh); }
      66% { transform: translateX(-20px) translateY(66vh); }
      to { transform: translateX(10px) translateY(calc(100vh + 20px)); opacity:0.5; }
    }
    
    @keyframes snowSwirl{ 
      0% { transform: translateX(0) translateY(0) rotate(0); }
      25% { transform: translateX(40px) translateY(25vh) rotate(90deg); }
      50% { transform: translateX(-30px) translateY(50vh) rotate(180deg); }
      75% { transform: translateX(20px) translateY(75vh) rotate(270deg); }
      100% { transform: translateX(0) translateY(calc(100vh + 20px)) rotate(360deg); opacity:0.4; }
    }
  </style>
</head>
<body>
  <div class="app" id="app">
    <header>
      <div class="title">üêß Penguin Angle Quiz</div>
      <div class="pill" id="progressPill">Question 1 of 3</div>
    </header>

    <div class="snow" id="snow"></div>
    <div class="wrap">
      <!-- Penguin Panel -->
      <section class="penguin-card">
        <!-- Penguin-specific snow layer -->
        <div class="penguin-snow" id="penguinSnow"></div>
        
        <div class="penguin-stage">
          <!-- Simple confetti (emojis) -->
          <div class="cele-confetti" id="confetti"></div>
          <svg id="penguinSvg" viewBox="0 0 200 220" width="100%" height="100%" aria-label="Penguin">
            <g id="penguin">
              <!-- shadow -->
              <ellipse cx="100" cy="200" rx="46" ry="10" fill="#bde9ff" opacity="0.6"/>
              <!-- body -->
              <ellipse cx="100" cy="120" rx="60" ry="80" fill="#2d3a4a" />
              <!-- belly -->
              <ellipse cx="100" cy="140" rx="40" ry="55" fill="#ffffff"/>
              <!-- face white -->
              <ellipse cx="100" cy="92" rx="38" ry="30" fill="#ffffff"/>
              <!-- wings -->
              <ellipse cx="46" cy="128" rx="16" ry="30" fill="#2d3a4a"/>
              <ellipse cx="154" cy="128" rx="16" ry="30" fill="#2d3a4a"/>
              <!-- eyes -->
              <g id="eyeL" class="eye">
                <circle cx="84" cy="88" r="11" fill="#fff" stroke="#222" stroke-width="2"/>
                <circle cx="84" cy="88" r="8" fill="#111" class="pupil pupilL"/>
                <circle cx="81" cy="85" r="2.6" fill="#fff" opacity="0.85"/>
              </g>
              <g id="eyeR" class="eye">
                <circle cx="116" cy="88" r="11" fill="#fff" stroke="#222" stroke-width="2"/>
                <circle cx="116" cy="88" r="8" fill="#111" class="pupil pupilR"/>
                <circle cx="113" cy="85" r="2.6" fill="#fff" opacity="0.85"/>
              </g>
              <!-- beak -->
              <polygon points="100,98 112,112 88,112" fill="#ffb34a"/>
              <!-- smile -->
              <path id="smile" d="M88,118 Q100,128 112,118" stroke="#ffb34a" stroke-width="4" fill="none" stroke-linecap="round"/>
              <!-- feet -->
              <ellipse cx="82" cy="188" rx="14" ry="7" fill="#ffb34a"/>
              <ellipse cx="118" cy="188" rx="14" ry="7" fill="#ffb34a"/>
              <!-- tiny tears (hidden until sad) -->
              <circle class="tear" id="tearL" cx="84" cy="96" r="2.5" fill="#7ad1ff"/>
              <circle class="tear" id="tearR" cx="116" cy="96" r="2.5" fill="#7ad1ff"/>
            </g>
          </svg>
          <div class="ground"></div>
        </div>
        <div class="score" id="scoreBox">Score: 0 / 3</div>
      </section>

      <!-- Game Panel -->
      <section class="play">
        <div class="progress" id="progressText">Measure the angle with your on-screen protractor!</div>
        <div class="board">
          <svg id="angleSvg" viewBox="0 0 620 410" aria-label="Angle to measure">
            <defs>
              <marker id="arrow" markerWidth="8" markerHeight="8" refX="6" refY="4" orient="auto-start-reverse">
                <path d="M0,0 L8,4 L0,8 z" fill="currentColor" />
              </marker>
            </defs>
            <!-- arc inside the angle vertex -->
            <path id="innerArcPath" class="arc inner" d="" />
            <!-- Hidden outer arc path for compatibility -->
            <path id="arcPath" class="arc" d="" style="display:none;" />
            <!-- baseline (horizontal) -->
            <line id="baseLine" class="base" x1="160" y1="300" x2="520" y2="300" />
            <!-- ray (angle arm) -->
            <line id="rayLine" class="ray" x1="160" y1="300" x2="160" y2="120" style="color:var(--accent)" marker-end="url(#arrow)" />
            <!-- vertex dot always above everything -->
            <circle id="vertexDot" class="vertex" cx="160" cy="300" r="6" />
          </svg>
        </div>
        <div class="tip">Tip: Place your physical or transparent on-screen protractor over the angle, then type the measure in degrees.</div>

        <div class="controls">
          <label for="answer"><strong>Your answer (¬∞):</strong></label>
          <input id="answer" type="number" inputmode="decimal" placeholder="e.g., 37" min="0" max="180" />
          <button class="btn" id="checkBtn">‚úÖ Check</button>
          <button class="btn secondary" id="nextBtn" disabled>Next ‚ñ∂</button>
          <button class="btn secondary" id="restartBtn" style="display:none;">‚Üª Restart</button>
        </div>
        <div class="feedback" id="feedback"></div>
      </section>
    </div>
  </div>

  <script>
    (()=>{
      const TOTAL_QUESTIONS = 3;
      const TOLERANCE = 5; // ¬±5¬∞ accepted

      const app = document.getElementById('app');
      const progressPill = document.getElementById('progressPill');
      const progressText = document.getElementById('progressText');
      const scoreBox = document.getElementById('scoreBox');
      const feedback = document.getElementById('feedback');
      const answer = document.getElementById('answer');
      const checkBtn = document.getElementById('checkBtn');
      const nextBtn = document.getElementById('nextBtn');
      const restartBtn = document.getElementById('restartBtn');

      const penguin = document.getElementById('penguin');
      const penguinSvg = document.getElementById('penguinSvg');
      const confetti = document.getElementById('confetti');

      // SVG angle elements
      const rayLine = document.getElementById('rayLine');
      const arcPath = document.getElementById('arcPath');
      const innerArcPath = document.getElementById('innerArcPath');
      const vertex = { x: 160, y: 300 };
      const RAY_LEN = 240; // length for the ray
      const ARC_R = 64; // radius of the angle arc

      // State
      let currentAngle = 0; // degrees
      let qIndex = 0;
      let score = 0;
      let finished = false;

      function rndAngle(){
        // Question 1: Obtuse (91-170¬∞)
        // Question 2: Acute (10-89¬∞)
        // Question 3: Obtuse (91-170¬∞)
        
        if(qIndex === 0) {
          // First question: obtuse angle
          return Math.floor(91 + Math.random() * 80); // 91..170
        } else if(qIndex === 1) {
          // Second question: acute angle
          return Math.floor(10 + Math.random() * 80); // 10..89
        } else {
          // Third question: obtuse angle
          return Math.floor(91 + Math.random() * 80); // 91..170
        }
      }

      function format(n){ return Math.round(n * 100) / 100; }

      function computeArcPoints(t){
        // start of arc on baseline
        const ax = vertex.x + ARC_R * Math.cos(0);
        const ay = vertex.y - ARC_R * Math.sin(0);
        // end of arc along ray
        const bx = vertex.x + ARC_R * Math.cos(t);
        const by = vertex.y - ARC_R * Math.sin(t);
        // control point outside the wedge to make the curve bulge outward
        const mid = t / 2; // bisector
        const k = ARC_R * 1.4;
        const cx = vertex.x - k * Math.cos(mid);
        const cy = vertex.y - k * Math.sin(mid); // + because SVG y increases downward
        return {ax,ay,bx,by,cx,cy};
      }

      function drawAngle(angleDeg){
        // Store the actual angle for reference
        currentAngle = angleDeg;
        
        // Convert to radians for calculations
        const t = (angleDeg * Math.PI) / 180;
        
        // Calculate ray endpoint
        // IMPORTANT: In standard math, angles go counter-clockwise from positive x-axis
        // But visually, we want angles measured from the horizontal baseline going upward
        const x2 = vertex.x + RAY_LEN * Math.cos(t);
        const y2 = vertex.y - RAY_LEN * Math.sin(t); // Negative because SVG y increases downward
        
        // Update ray position
        rayLine.setAttribute('x1', vertex.x);
        rayLine.setAttribute('y1', vertex.y);
        rayLine.setAttribute('x2', Math.round(x2));
        rayLine.setAttribute('y2', Math.round(y2));

        // Clear the outer arc (not used)
        arcPath.setAttribute('d', '');
        arcPath.dataset.cy = '0';

        // Draw the angle arc at the vertex
        const ARC_RADIUS = 42;
        
        // Start point is on the baseline (horizontal right)
        const startX = vertex.x + ARC_RADIUS;
        const startY = vertex.y;
        
        // End point is along the ray
        const endX = vertex.x + ARC_RADIUS * Math.cos(t);
        const endY = vertex.y - ARC_RADIUS * Math.sin(t);
        
        // SVG arc parameters
        const largeArcFlag = angleDeg > 180 ? 1 : 0;
        const sweepFlag = 0; // Counter-clockwise in math coords (appears clockwise visually)
        
        // Create the arc path
        const arcPathData = `M ${startX} ${startY} A ${ARC_RADIUS} ${ARC_RADIUS} 0 ${largeArcFlag} ${sweepFlag} ${Math.round(endX)} ${Math.round(endY)}`;
        innerArcPath.setAttribute('d', arcPathData);
        
        // Debug output
        console.log(`Angle drawn: ${angleDeg}¬∞`);
        console.log(`Ray endpoint: (${Math.round(x2)}, ${Math.round(y2)})`);
        
        // Make angle accessible for debugging
        window.currentAngle = angleDeg;
      }

      function setPenguinState(state){
        // state: 'idle' | 'happy' | 'sad'
        penguin.classList.remove('celebrate','sad');
        app.classList.remove('celebrate-on');
        confetti.innerHTML = '';
        penguinSvg.classList.remove('cry','happy');
        if(state === 'happy'){
          penguin.classList.add('celebrate');
          penguinSvg.classList.add('happy');
          app.classList.add('celebrate-on');
          launchConfetti();
        }else if(state === 'sad'){
          penguin.classList.add('sad');
          penguinSvg.classList.add('cry');
          // offset left/right tears timings
          const tearL = document.getElementById('tearL');
          const tearR = document.getElementById('tearR');
          tearL.style.animationDelay = '0s';
          tearR.style.animationDelay = '0.25s';
        }
      }

      function launchConfetti(){
        // simple emoji confetti for kids
        const pieces = 24;
        const emojis = ['üéâ','‚ú®','üéä','‚≠ê','üß°','üíô','üíõ'];
        confetti.innerHTML = '';
        for(let i=0;i<pieces;i++){
          const span = document.createElement('span');
          span.textContent = emojis[Math.floor(Math.random()*emojis.length)];
          const left = Math.random()*100;
          const dur = 0.9 + Math.random()*0.8;
          const delay = Math.random()*0.2;
          span.style.position='absolute';
          span.style.left = left+'%';
          span.style.top = '-10px';
          span.style.fontSize = (18 + Math.random()*16)+'px';
          span.style.animation = `fall ${dur}s ease-in ${delay}s forwards`;
          confetti.appendChild(span);
        }
      }

      const style = document.createElement('style');
      style.textContent = `@keyframes fall{0%{transform:translateY(0) rotate(0)} 100%{transform:translateY(240px) rotate(90deg); opacity:0}}`;
      document.head.appendChild(style);

      function newQuestion(){
        if(qIndex >= TOTAL_QUESTIONS){ finishQuiz(); return; }
        
        // Generate the angle based on question number
        currentAngle = rndAngle();
        
        // Draw the angle
        drawAngle(currentAngle);
        
        // Update UI
        progressPill.textContent = `Question ${qIndex+1} of ${TOTAL_QUESTIONS}`;
        progressText.textContent = `Measure this angle and type your answer in degrees (¬±${TOLERANCE}¬∞ allowed).`;
        feedback.textContent = '';
        answer.value = '';
        answer.focus();
        nextBtn.disabled = true;
        checkBtn.disabled = false;
        setPenguinState('idle');
        
        // Debug helper
        console.log(`%cQuestion ${qIndex+1}: The angle is ${currentAngle}¬∞ (Type window.currentAngle in console to check)`, 'color: blue; font-weight: bold');
      }

      function finishQuiz(){
        finished = true;
        progressPill.textContent = `All done!`;
        progressText.textContent = `Great work! You finished ${TOTAL_QUESTIONS} questions.`;
        feedback.innerHTML = score === TOTAL_QUESTIONS
          ? `üêß <span class="good">Perfect! ${score}/${TOTAL_QUESTIONS}</span> ‚Äî Penguin is super proud!`
          : `üêß You scored <strong>${score}/${TOTAL_QUESTIONS}</strong>. Want to try again?`;
        checkBtn.disabled = true;
        nextBtn.disabled = true;
        restartBtn.style.display = 'inline-block';
        setPenguinState(score === TOTAL_QUESTIONS ? 'happy' : 'idle');
      }

      function updateScore(){ scoreBox.textContent = `Score: ${score} / ${TOTAL_QUESTIONS}`; }

      function isWithinTolerance(val, target, tol=TOLERANCE){
        return Math.abs(val - target) <= tol;
      }

      function checkAnswer(){
        if(finished) return;
        const userAnswer = parseFloat(answer.value);
        
        if(Number.isNaN(userAnswer)){
          feedback.innerHTML = '<span class="bad">Please type a number in degrees.</span>';
          setPenguinState('sad');
          return;
        }
        
        // Check if the answer is within tolerance
        const difference = Math.abs(userAnswer - currentAngle);
        const isCorrect = difference <= TOLERANCE;
        
        console.log(`Checking: User answered ${userAnswer}¬∞, Expected ${currentAngle}¬∞, Difference: ${difference}¬∞`);
        
        if(isCorrect){
          feedback.innerHTML = `‚úÖ <span class="good">Correct!</span> The angle is <strong>${currentAngle}¬∞</strong>.`;
          setPenguinState('happy');
          score++;
          updateScore();
          nextBtn.disabled = false;
          checkBtn.disabled = true;
        } else {
          setPenguinState('sad');
          
          if(difference >= 15){
            feedback.innerHTML = `‚ùå <span class="bad">Almost! You're off by about ${Math.round(difference)}¬∞.</span> Try measuring again.`;
          } else {
            feedback.innerHTML = `‚ùå <span class="bad">Not yet.</span> You're close! Re-check your protractor placement.`;
          }
          
          // Help debug by showing what the angle should be (remove this in production)
          console.log(`Hint: The correct angle is ${currentAngle}¬∞`);
        }
      }

      function next(){ if(finished) return; qIndex++; newQuestion(); }
      function restart(){ finished = false; qIndex = 0; score = 0; updateScore(); restartBtn.style.display='none'; newQuestion(); }

      checkBtn.addEventListener('click', checkAnswer);
      nextBtn.addEventListener('click', next);
      restartBtn.addEventListener('click', restart);
      answer.addEventListener('keydown', (e)=>{ if(e.key==='Enter'){ checkAnswer(); }});

      // ----------------------
      // Simple DEV TESTS
      // ----------------------
      (function runDevTests(){
        try {
          let passed = 0, total = 0;
          // Test 1: rndAngle bounds
          total++; const samples = Array.from({length:50}, rndAngle); const inRange = samples.every(a=>a>=10 && a<=170); if(inRange) passed++;
          // Test 2: drawAngle doesn't throw and sets arcPath
          total++; [10,45,90,120,170].forEach(a=>drawAngle(a)); const hasD = arcPath.getAttribute('d')?.length>0; if(hasD) passed++;
          // Test 3: tolerance exact
          total++; if(isWithinTolerance(50,50,5)) passed++;
          // Test 4: tolerance boundary
          total++; if(isWithinTolerance(55,50,5) && isWithinTolerance(45,50,5)) passed++;
          // Test 5: tolerance fail just over
          total++; if(!isWithinTolerance(56,50,5) && !isWithinTolerance(44,50,5)) passed++;
          console.log(`DEV TESTS: ${passed}/${total} passed`);
        } catch (e){ console.error('DEV TESTS error:', e); }
      })();

      // Enhanced snow initialization with multiple layers
      function initSnow(){
        // Background snow (entire app)
        const snow = document.getElementById('snow');
        if(snow) {
          createSnowflakes(snow, 120, 'full');
        }
        
        // Foreground snow (penguin area)
        const penguinSnow = document.getElementById('penguinSnow');
        if(penguinSnow) {
          createSnowflakes(penguinSnow, 40, 'penguin');
        }
      }
      
      function createSnowflakes(container, count, type){
        container.innerHTML = '';
        const animations = ['snowFall', 'snowDrift', 'snowSwirl'];
        
        for(let i = 0; i < count; i++){
          const s = document.createElement('span');
          const size = type === 'penguin' 
            ? 3 + Math.random() * 5  // Slightly larger for foreground
            : 4 + Math.random() * 8; // Larger for background
          
          s.style.left = (Math.random() * 100) + '%';
          s.style.width = s.style.height = size + 'px';
          
          // Vary animation types for more natural movement
          const animType = animations[Math.floor(Math.random() * animations.length)];
          const duration = type === 'penguin'
            ? 3 + Math.random() * 5  // Faster for foreground
            : 5 + Math.random() * 8; // Slower for background
          
          s.style.animationName = animType;
          s.style.animationDuration = duration + 's';
          s.style.animationDelay = (Math.random() * 8) + 's';
          s.style.opacity = type === 'penguin'
            ? (0.7 + Math.random() * 0.3).toFixed(2)  // More visible
            : (0.8 + Math.random() * 0.2).toFixed(2); // More opaque
          
          // Add some blur to distant snowflakes
          if(Math.random() > 0.6) {
            s.style.filter = `drop-shadow(0 0 ${3 + Math.random() * 3}px #fff) blur(${Math.random() * 0.5}px)`;
          }
          
          container.appendChild(s);
        }
      }

      // tiny console tests
      function runTests(){
        try{
          drawAngle(30);
          // Since we removed the outer arc, skip that test
          if(!innerArcPath.getAttribute('d').includes('A')) throw new Error('Inner vertex arc should use A');
          drawAngle(120);
          if(!/A/.test(innerArcPath.getAttribute('d'))) throw new Error('Inner arc present for obtuse');
          console.log('%cUI tests passed','color:green');
        }catch(e){ console.error('Tests failed:', e.message); }
      }

      // init
      updateScore();
      initSnow();
      newQuestion();
      runTests();
    })();
  </script>
</body>
</html>
